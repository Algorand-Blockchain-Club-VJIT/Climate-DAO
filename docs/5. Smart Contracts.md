# 5. Smart Contracts

## 5.1 Overview

The AI-G-DAO smart contract system is built on the Algorand blockchain using Python and the AlgoKit framework. Our contracts provide the foundation for democratic governance, transparent proposal management, and automated Climate Impact Credit (CIC) distribution while maintaining carbon-negative operations.

## 5.2 Contract Architecture

### 5.2.1 Project Structure

```
contracts/climate-dao/
├── climate-dao.code-workspace
├── README.md
└── projects/
    └── climate-dao/
        ├── poetry.lock
        ├── poetry.toml
        ├── pyproject.toml
        ├── README.md
        └── smart_contracts/
            ├── __init__.py
            ├── __main__.py                  # Deployment entry point
            └── climate_dao/
                ├── contract.py              # Main contract logic
                ├── state.py                 # State management
                ├── operations.py            # Core operations
                └── governance.py            # Governance functions
```

### 5.2.2 Development Environment

#### Dependencies
```toml
[tool.poetry.dependencies]
python = "^3.12"
algokit-utils = "^2.0.0"
algosdk = "^2.0.0"
puyapy = "^1.0.0"

[tool.poetry.group.dev.dependencies]
algokit-client-generator = "^1.0.0"
pytest = "^7.0.0"
pytest-cov = "^4.0.0"
```

#### AlgoKit Configuration
- **Framework**: AlgoKit for standardized development
- **Language**: Python with Puya compiler
- **Network**: Algorand TestNet (production-ready for MainNet)
- **Deployment**: Automated deployment scripts

## 5.3 Core Contract: Climate DAO

### 5.3.1 Contract State (`state.py`)

#### Global State Schema
```python
from typing import TypedDict
from algopy import GlobalState, UInt64, Bytes

class GlobalStateSchema(TypedDict):
    # Governance Parameters
    proposal_count: UInt64              # Total number of proposals
    active_proposals: UInt64            # Currently active proposals
    min_vote_threshold: UInt64          # Minimum votes required
    voting_duration: UInt64             # Voting period in blocks
    
    # Credit System
    total_credits_issued: UInt64        # Total CIC tokens issued
    credit_multiplier: UInt64           # Credit calculation multiplier
    
    # Admin Controls
    admin_address: Bytes                # Contract administrator
    emergency_pause: UInt64             # Emergency pause flag
    
    # AI Integration
    ai_analysis_required: UInt64        # Require AI analysis flag
    min_ai_score: UInt64               # Minimum AI score threshold
```

#### Local State Schema
```python
class LocalStateSchema(TypedDict):
    # User Governance
    voting_power: UInt64                # User's voting weight
    proposals_submitted: UInt64         # Number of proposals submitted
    votes_cast: UInt64                  # Number of votes cast
    
    # Credit Holdings
    cic_balance: UInt64                 # Climate Impact Credits balance
    credits_earned: UInt64              # Total credits earned
    
    # Participation Metrics
    last_activity: UInt64               # Last interaction timestamp
    reputation_score: UInt64            # Community reputation
```

### 5.3.2 Proposal Management (`operations.py`)

#### Proposal Structure
```python
from algopy import Struct, Bytes, UInt64

class Proposal(Struct):
    id: UInt64                          # Unique proposal identifier
    title: Bytes                        # Proposal title (max 64 bytes)
    description: Bytes                  # Proposal description
    proposer: Bytes                     # Proposer's address
    
    # AI Analysis Results
    ai_score: UInt64                    # Overall AI analysis score (0-100)
    environmental_score: UInt64         # Environmental impact score
    feasibility_score: UInt64           # Technical feasibility score
    risk_score: UInt64                  # Risk assessment score
    
    # Voting Data
    votes_for: UInt64                   # Supporting votes
    votes_against: UInt64               # Opposing votes
    total_voters: UInt64                # Number of unique voters
    
    # Timestamps
    submission_time: UInt64             # Proposal submission timestamp
    voting_start: UInt64                # Voting period start
    voting_end: UInt64                  # Voting period end
    
    # Status
    status: UInt64                      # Proposal status enum
    execution_time: UInt64              # Execution timestamp (if approved)
```

#### Proposal Operations
```python
@subroutine
def submit_proposal(
    title: Bytes,
    description: Bytes,
    ai_analysis_data: Bytes
) -> UInt64:
    """
    Submit a new climate project proposal
    
    Args:
        title: Proposal title (max 64 bytes)
        description: Detailed project description
        ai_analysis_data: Serialized AI analysis results
    
    Returns:
        proposal_id: Unique identifier for the new proposal
    """
    # Validate proposer eligibility
    assert Txn.sender != Global.zero_address
    
    # Parse AI analysis data
    ai_scores = parse_ai_analysis(ai_analysis_data)
    
    # Validate minimum AI score threshold
    assert ai_scores.overall_score >= GlobalState.min_ai_score
    
    # Create new proposal
    proposal_id = GlobalState.proposal_count + 1
    proposal = Proposal(
        id=proposal_id,
        title=title,
        description=description,
        proposer=Txn.sender,
        ai_score=ai_scores.overall_score,
        environmental_score=ai_scores.environmental_score,
        feasibility_score=ai_scores.feasibility_score,
        risk_score=ai_scores.risk_score,
        votes_for=0,
        votes_against=0,
        total_voters=0,
        submission_time=Global.latest_timestamp,
        voting_start=Global.latest_timestamp + REVIEW_PERIOD,
        voting_end=Global.latest_timestamp + REVIEW_PERIOD + VOTING_PERIOD,
        status=ProposalStatus.UNDER_REVIEW,
        execution_time=0
    )
    
    # Store proposal
    store_proposal(proposal_id, proposal)
    
    # Update global state
    GlobalState.proposal_count = proposal_id
    GlobalState.active_proposals += 1
    
    # Update proposer's local state
    LocalState[Txn.sender].proposals_submitted += 1
    
    return proposal_id

@subroutine
def vote_on_proposal(proposal_id: UInt64, vote: UInt64) -> None:
    """
    Cast vote on an active proposal
    
    Args:
        proposal_id: ID of the proposal to vote on
        vote: 1 for support, 0 for opposition
    """
    # Validate proposal exists and is active
    proposal = get_proposal(proposal_id)
    assert proposal.status == ProposalStatus.ACTIVE_VOTING
    
    # Validate voting period
    assert Global.latest_timestamp >= proposal.voting_start
    assert Global.latest_timestamp <= proposal.voting_end
    
    # Validate voter hasn't already voted
    voter_key = concat(b"vote_", itob(proposal_id), b"_", Txn.sender)
    assert not App.box_get(voter_key).did_exist
    
    # Calculate voting power
    voting_power = calculate_voting_power(Txn.sender)
    
    # Record vote
    if vote == 1:
        proposal.votes_for += voting_power
    else:
        proposal.votes_against += voting_power
    
    proposal.total_voters += 1
    
    # Store updated proposal
    store_proposal(proposal_id, proposal)
    
    # Mark voter as having voted
    App.box_put(voter_key, itob(voting_power))
    
    # Update voter's local state
    LocalState[Txn.sender].votes_cast += 1
    LocalState[Txn.sender].last_activity = Global.latest_timestamp
```

### 5.3.3 Governance System (`governance.py`)

#### Voting Power Calculation
```python
@subroutine
def calculate_voting_power(address: Bytes) -> UInt64:
    """
    Calculate voting power based on multiple factors
    
    Args:
        address: Voter's address
    
    Returns:
        voting_power: Calculated voting power
    """
    base_power = UInt64(1)  # Base voting power for all participants
    
    # CIC token holdings (weighted at 50%)
    cic_balance = LocalState[address].cic_balance
    cic_power = cic_balance // 1000  # 1 voting power per 1000 CIC
    
    # Participation history (weighted at 30%)
    votes_cast = LocalState[address].votes_cast
    proposals_submitted = LocalState[address].proposals_submitted
    participation_power = (votes_cast + (proposals_submitted * 5)) // 10
    
    # Reputation score (weighted at 20%)
    reputation = LocalState[address].reputation_score
    reputation_power = reputation // 100
    
    # Calculate total voting power
    total_power = base_power + cic_power + participation_power + reputation_power
    
    # Cap maximum voting power to prevent centralization
    max_power = UInt64(1000)
    return min(total_power, max_power)

@subroutine
def finalize_proposal(proposal_id: UInt64) -> None:
    """
    Finalize proposal voting and determine outcome
    
    Args:
        proposal_id: ID of the proposal to finalize
    """
    proposal = get_proposal(proposal_id)
    
    # Validate voting period has ended
    assert Global.latest_timestamp > proposal.voting_end
    assert proposal.status == ProposalStatus.ACTIVE_VOTING
    
    # Check if minimum participation threshold is met
    total_votes = proposal.votes_for + proposal.votes_against
    assert total_votes >= GlobalState.min_vote_threshold
    
    # Determine proposal outcome
    if proposal.votes_for > proposal.votes_against:
        proposal.status = ProposalStatus.APPROVED
        proposal.execution_time = Global.latest_timestamp + EXECUTION_DELAY
        
        # Schedule credit distribution
        schedule_credit_distribution(proposal)
    else:
        proposal.status = ProposalStatus.REJECTED
    
    # Update global state
    GlobalState.active_proposals -= 1
    
    # Store updated proposal
    store_proposal(proposal_id, proposal)
```

### 5.3.4 Climate Impact Credits (`credits.py`)

#### Credit Distribution Algorithm
```python
@subroutine
def calculate_credit_amount(proposal: Proposal) -> UInt64:
    """
    Calculate CIC amount based on AI analysis and project scope
    
    Args:
        proposal: Approved proposal
    
    Returns:
        credit_amount: Number of CIC tokens to distribute
    """
    # Base credit calculation from AI scores
    environmental_factor = proposal.environmental_score
    feasibility_factor = proposal.feasibility_score
    risk_factor = UInt64(100) - proposal.risk_score  # Lower risk = higher credits
    
    # Calculate base credits
    base_credits = (environmental_factor + feasibility_factor + risk_factor) // 3
    
    # Apply global multiplier
    multiplier = GlobalState.credit_multiplier
    total_credits = (base_credits * multiplier) // 100
    
    # Bonus for high-impact projects
    if proposal.ai_score >= 90:
        total_credits = (total_credits * 120) // 100  # 20% bonus
    elif proposal.ai_score >= 80:
        total_credits = (total_credits * 110) // 100  # 10% bonus
    
    return total_credits

@subroutine
def distribute_credits(proposal_id: UInt64) -> None:
    """
    Distribute CIC tokens for approved proposal
    
    Args:
        proposal_id: ID of the approved proposal
    """
    proposal = get_proposal(proposal_id)
    
    # Validate proposal is approved and ready for execution
    assert proposal.status == ProposalStatus.APPROVED
    assert Global.latest_timestamp >= proposal.execution_time
    
    # Calculate credit amount
    credit_amount = calculate_credit_amount(proposal)
    
    # Distribute credits to proposer (70%)
    proposer_credits = (credit_amount * 70) // 100
    LocalState[proposal.proposer].cic_balance += proposer_credits
    LocalState[proposal.proposer].credits_earned += proposer_credits
    
    # Distribute credits to voters (30%)
    voter_credits = credit_amount - proposer_credits
    distribute_voter_credits(proposal_id, voter_credits)
    
    # Update global credit tracking
    GlobalState.total_credits_issued += credit_amount
    
    # Mark proposal as executed
    proposal.status = ProposalStatus.EXECUTED
    store_proposal(proposal_id, proposal)

@subroutine
def distribute_voter_credits(proposal_id: UInt64, total_voter_credits: UInt64) -> None:
    """
    Distribute credits among proposal voters
    
    Args:
        proposal_id: ID of the proposal
        total_voter_credits: Total credits to distribute among voters
    """
    proposal = get_proposal(proposal_id)
    
    # Calculate credits per voter (equal distribution)
    if proposal.total_voters > 0:
        credits_per_voter = total_voter_credits // proposal.total_voters
        
        # Iterate through voters and distribute credits
        # (In practice, this would be done through a separate mechanism
        # due to Algorand's transaction limits)
        for i in range(proposal.total_voters):
            voter_key = get_voter_key(proposal_id, i)
            voter_address = get_voter_address(voter_key)
            
            LocalState[voter_address].cic_balance += credits_per_voter
            LocalState[voter_address].credits_earned += credits_per_voter
```

## 5.4 Contract Deployment

### 5.4.1 Deployment Script (`__main__.py`)

```python
import logging
from algosdk import account
from algokit_utils import ApplicationClient, get_localnet_default_account

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def deploy_climate_dao():
    """Deploy Climate DAO contract to Algorand network"""
    
    # Get deployment account
    deployer = get_localnet_default_account()
    logger.info(f"Deploying with account: {deployer.address}")
    
    # Create application client
    app_client = ApplicationClient(
        algod_client=get_algod_client(),
        app_spec=get_app_spec(),
        sender=deployer.address,
        signer=deployer.signer
    )
    
    # Deploy contract
    create_response = app_client.create(
        extra_pages=1,  # Additional storage pages
        note="Climate DAO v1.0 - AI-Powered Climate Governance"
    )
    
    app_id = create_response.app_id
    logger.info(f"Contract deployed with App ID: {app_id}")
    
    # Initialize contract state
    app_client.call(
        "initialize",
        min_vote_threshold=100,
        voting_duration=17280,  # 24 hours in blocks
        credit_multiplier=100,
        min_ai_score=70
    )
    
    logger.info("Contract initialization complete")
    return app_id

if __name__ == "__main__":
    deploy_climate_dao()
```

### 5.4.2 Network Configuration

#### TestNet Deployment
```bash
# Deploy to Algorand TestNet
algokit project deploy --network testnet

# Verify deployment
algokit project verify --app-id <APP_ID> --network testnet
```

#### MainNet Preparation
```bash
# Audit preparation
algokit project audit --comprehensive

# Security checks
algokit project security-scan

# Performance analysis
algokit project benchmark
```

## 5.5 Security Considerations

### 5.5.1 Access Control

#### Admin Functions
- **Emergency Pause**: Ability to pause contract in case of vulnerabilities
- **Parameter Updates**: Ability to adjust governance parameters
- **Upgrade Path**: Mechanism for contract upgrades

#### User Permissions
- **Proposal Submission**: Open to all users with minimum stake
- **Voting Rights**: Based on calculated voting power
- **Credit Claims**: Automated distribution based on participation

### 5.5.2 Validation & Security

#### Input Validation
```python
@subroutine
def validate_proposal_input(title: Bytes, description: Bytes) -> None:
    """Validate proposal input parameters"""
    
    # Title validation
    assert len(title) > 0
    assert len(title) <= 64
    
    # Description validation
    assert len(description) > 0
    assert len(description) <= 1024
    
    # Content validation (basic checks)
    assert title != description  # Prevent duplicate content
```

#### Reentrancy Protection
```python
# Global reentrancy guard
reentrancy_guard: UInt64 = UInt64(0)

@subroutine
def nonreentrant_call(operation: Callable) -> None:
    """Prevent reentrancy attacks"""
    assert reentrancy_guard == 0
    reentrancy_guard = UInt64(1)
    
    operation()
    
    reentrancy_guard = UInt64(0)
```

### 5.5.3 Economic Security

#### Spam Prevention
- **Minimum Stake**: Require minimum CIC balance for proposal submission
- **Cooldown Period**: Prevent rapid-fire proposal submissions
- **Quality Scoring**: AI analysis requirements filter low-quality proposals

#### Sybil Resistance
- **Voting Power Caps**: Maximum voting power limits prevent centralization
- **Reputation System**: Long-term participation builds voting weight
- **Economic Barriers**: CIC token requirements for meaningful participation

## 5.6 Monitoring & Analytics

### 5.6.1 Contract Events

```python
# Event logging for off-chain monitoring
def log_proposal_submitted(proposal_id: UInt64, proposer: Bytes) -> None:
    log(b"ProposalSubmitted", proposal_id, proposer)

def log_vote_cast(proposal_id: UInt64, voter: Bytes, vote: UInt64) -> None:
    log(b"VoteCast", proposal_id, voter, vote)

def log_credits_distributed(recipient: Bytes, amount: UInt64) -> None:
    log(b"CreditsDistributed", recipient, amount)
```

### 5.6.2 Performance Metrics

#### Gas Optimization
- **Efficient Storage**: Optimized state schema for minimal storage costs
- **Batch Operations**: Group related operations to reduce transaction fees
- **Lazy Evaluation**: Defer expensive calculations when possible

#### Scalability Features
- **Box Storage**: Use Algorand boxes for large data structures
- **State Pruning**: Archive old proposals to maintain performance
- **Pagination**: Support for large-scale data retrieval

This smart contract architecture provides a robust, secure, and scalable foundation for the AI-G-DAO platform, enabling transparent governance and automated credit distribution while maintaining the highest standards of blockchain security and efficiency.
